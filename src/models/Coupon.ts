// src/models/Coupon.ts
import mongoose, { Document, Schema } from 'mongoose';

export interface ICoupon extends Document {
  _id: string;
  
  // Basic info
  code: string;
  name: string;
  description?: string;
  
  // Discount
  discountType: 'percentage' | 'fixed' | 'free_shipping' | 'buy_x_get_y';
  discountValue: number; // Percentage (1-100) or fixed amount
  maximumDiscount?: number; // Maximum discount for percentage coupons
  
  // Usage limits
  usageLimit?: number; // Total usage limit
  usageLimitPerCustomer?: number; // Per customer limit
  usageCount: number; // Current usage count
  
  // Date restrictions
  startDate?: Date;
  endDate?: Date;
  
  // Amount restrictions
  minimumAmount?: number;
  maximumAmount?: number;
  
  // Product/Category restrictions
  applicableProducts: string[]; // Product IDs
  excludedProducts: string[]; // Product IDs
  applicableCategories: string[]; // Category IDs
  excludedCategories: string[]; // Category IDs
  applicableBrands: string[]; // Brand IDs
  excludedBrands: string[]; // Brand IDs
  
  // Customer restrictions
  applicableCustomers: string[]; // User IDs (empty = all customers)
  excludedCustomers: string[]; // User IDs
  customerGroups: string[]; // Customer groups/roles
  newCustomersOnly: boolean;
  
  // Buy X Get Y settings (for buy_x_get_y type)
  buyXGetY?: {
    buyQuantity: number;
    getQuantity: number;
    buyProducts: string[]; // Product IDs to buy
    getProducts: string[]; // Product IDs to get (empty = same as buy)
    getDiscountType: 'percentage' | 'fixed' | 'free';
    getDiscountValue: number;
  };
  
  // Combination settings
  canCombineWithOtherCoupons: boolean;
  canCombineWithSales: boolean;
  
  // Status
  status: 'active' | 'inactive' | 'expired' | 'used_up';
  
  // Auto-generation settings
  isAutoGenerated: boolean;
  generatedFrom?: string; // Template coupon ID
  
  // Metadata
  source: 'manual' | 'campaign' | 'loyalty' | 'referral' | 'abandoned_cart';
  createdBy?: string; // Admin user ID
  
  // Timestamps
  createdAt: Date;
  updatedAt: Date;
  
  // Virtual fields
  isValid: boolean;
  isExpired: boolean;
  isUsedUp: boolean;
  remainingUses: number;
}

const BuyXGetYSchema = new Schema({
  buyQuantity: {
    type: Number,
    required: true,
    min: 1,
  },
  getQuantity: {
    type: Number,
    required: true,
    min: 1,
  },
  buyProducts: [{
    type: Schema.Types.ObjectId,
    ref: 'Product',
  }],
  getProducts: [{
    type: Schema.Types.ObjectId,
    ref: 'Product',
  }],
  getDiscountType: {
    type: String,
    enum: ['percentage', 'fixed', 'free'],
    default: 'free',
  },
  getDiscountValue: {
    type: Number,
    default: 0,
    min: 0,
  },
}, {
  _id: false,
});

const CouponSchema = new Schema({
  // Basic info
  code: {
    type: String,
    required: true,
    unique: true,
    uppercase: true,
    trim: true,
    maxlength: 50,
    index: true,
  },
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 100,
  },
  description: {
    type: String,
    trim: true,
    maxlength: 500,
  },
  
  // Discount
  discountType: {
    type: String,
    enum: ['percentage', 'fixed', 'free_shipping', 'buy_x_get_y'],
    required: true,
    index: true,
  },
  discountValue: {
    type: Number,
    required: true,
    min: 0,
  },
  maximumDiscount: {
    type: Number,
    min: 0,
  },
  
  // Usage limits
  usageLimit: {
    type: Number,
    min: 1,
  },
  usageLimitPerCustomer: {
    type: Number,
    min: 1,
  },
  usageCount: {
    type: Number,
    default: 0,
    min: 0,
    index: true,
  },
  
  // Date restrictions
  startDate: {
    type: Date,
    index: true,
  },
  endDate: {
    type: Date,
    index: true,
  },
  
  // Amount restrictions
  minimumAmount: {
    type: Number,
    min: 0,
  },
  maximumAmount: {
    type: Number,
    min: 0,
  },
  
  // Product/Category restrictions
  applicableProducts: [{
    type: Schema.Types.ObjectId,
    ref: 'Product',
  }],
  excludedProducts: [{
    type: Schema.Types.ObjectId,
    ref: 'Product',
  }],
  applicableCategories: [{
    type: Schema.Types.ObjectId,
    ref: 'Category',
  }],
  excludedCategories: [{
    type: Schema.Types.ObjectId,
    ref: 'Category',
  }],
  applicableBrands: [{
    type: Schema.Types.ObjectId,
    ref: 'Brand',
  }],
  excludedBrands: [{
    type: Schema.Types.ObjectId,
    ref: 'Brand',
  }],
  
  // Customer restrictions
  applicableCustomers: [{
    type: Schema.Types.ObjectId,
    ref: 'User',
  }],
  excludedCustomers: [{
    type: Schema.Types.ObjectId,
    ref: 'User',
  }],
  customerGroups: [{
    type: String,
    enum: ['customer', 'vip', 'wholesale', 'premium'],
  }],
  newCustomersOnly: {
    type: Boolean,
    default: false,
    index: true,
  },
  
  // Buy X Get Y
  buyXGetY: BuyXGetYSchema,
  
  // Combination settings
  canCombineWithOtherCoupons: {
    type: Boolean,
    default: false,
  },
  canCombineWithSales: {
    type: Boolean,
    default: true,
  },
  
  // Status
  status: {
    type: String,
    enum: ['active', 'inactive', 'expired', 'used_up'],
    default: 'active',
    index: true,
  },
  
  // Auto-generation
  isAutoGenerated: {
    type: Boolean,
    default: false,
    index: true,
  },
  generatedFrom: {
    type: Schema.Types.ObjectId,
    ref: 'Coupon',
  },
  
  // Metadata
  source: {
    type: String,
    enum: ['manual', 'campaign', 'loyalty', 'referral', 'abandoned_cart'],
    default: 'manual',
    index: true,
  },
  createdBy: {
    type: Schema.Types.ObjectId,
    ref: 'User',
  },
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true },
});

// Indexes
CouponSchema.index({ status: 1, startDate: 1, endDate: 1 });
CouponSchema.index({ discountType: 1, status: 1 });
CouponSchema.index({ source: 1, status: 1 });
CouponSchema.index({ createdAt: -1 });

// Compound indexes
CouponSchema.index({ code: 1, status: 1 });

// Virtuals
CouponSchema.virtual('isValid').get(function(this: ICoupon) {
  const now = new Date();
  
  if (this.status !== 'active') return false;
  if (this.startDate && this.startDate > now) return false;
  if (this.endDate && this.endDate < now) return false;
  if (this.usageLimit && this.usageCount >= this.usageLimit) return false;
  
  return true;
});

CouponSchema.virtual('isExpired').get(function(this: ICoupon) {
  return this.endDate ? this.endDate < new Date() : false;
});

CouponSchema.virtual('isUsedUp').get(function(this: ICoupon) {
  return this.usageLimit ? this.usageCount >= this.usageLimit : false;
});

CouponSchema.virtual('remainingUses').get(function(this: ICoupon) {
  if (!this.usageLimit) return Infinity;
  return Math.max(0, this.usageLimit - this.usageCount);
});

// Pre-save middleware
CouponSchema.pre('save', function(this: ICoupon, next) {
  // Auto-update status based on conditions
  if (this.isExpired) {
    this.status = 'expired';
  } else if (this.isUsedUp) {
    this.status = 'used_up';
  }
  
  // Validate buy_x_get_y settings
  if (this.discountType === 'buy_x_get_y') {
    if (!this.buyXGetY) {
      return next(new Error('Buy X Get Y settings are required for this discount type'));
    }
  }
  
  // Validate discount value for percentage
  if (this.discountType === 'percentage' && this.discountValue > 100) {
    return next(new Error('Percentage discount cannot exceed 100%'));
  }
  
  next();
});

// Static methods
CouponSchema.statics.findActive = function() {
  const now = new Date();
  return this.find({
    status: 'active',
    $or: [
      { startDate: { $exists: false } },
      { startDate: { $lte: now } }
    ],
    $or: [
      { endDate: { $exists: false } },
      { endDate: { $gte: now } }
    ]
  });
};

CouponSchema.statics.findByCode = function(code: string) {
  return this.findOne({ 
    code: code.toUpperCase(),
    status: 'active'
  });
};

CouponSchema.statics.findExpired = function() {
  return this.find({
    endDate: { $lt: new Date() },
    status: { $ne: 'expired' }
  });
};

CouponSchema.statics.findUsedUp = function() {
  return this.find({
    $expr: { $gte: ['$usageCount', '$usageLimit'] },
    usageLimit: { $exists: true },
    status: { $ne: 'used_up' }
  });
};

CouponSchema.statics.generateUniqueCode = async function(length: number = 8, prefix?: string) {
  let code: string;
  let exists = true;
  
  while (exists) {
    const randomPart = Math.random().toString(36).substr(2, length).toUpperCase();
    code = prefix ? `${prefix}${randomPart}` : randomPart;
    
    const existing = await this.findOne({ code });
    exists = !!existing;
  }
  
  return code;
};

CouponSchema.statics.updateExpiredCoupons = function() {
  return this.updateMany(
    {
      endDate: { $lt: new Date() },
      status: { $ne: 'expired' }
    },
    {
      $set: { status: 'expired' }
    }
  );
};

CouponSchema.statics.updateUsedUpCoupons = function() {
  return this.updateMany(
    {
      $expr: { $gte: ['$usageCount', '$usageLimit'] },
      usageLimit: { $exists: true },
      status: { $ne: 'used_up' }
    },
    {
      $set: { status: 'used_up' }
    }
  );
};

// Instance methods
CouponSchema.methods.validateForCustomer = function(customerId?: string, orderTotal?: number) {
  const errors = [];
  
  if (!this.isValid) {
    if (this.status !== 'active') errors.push('Coupon is not active');
    if (this.isExpired) errors.push('Coupon has expired');
    if (this.isUsedUp) errors.push('Coupon usage limit reached');
  }
  
  if (this.minimumAmount && orderTotal && orderTotal < this.minimumAmount) {
    errors.push(`Minimum order amount of $${this.minimumAmount} required`);
  }
  
  if (this.maximumAmount && orderTotal && orderTotal > this.maximumAmount) {
    errors.push(`Maximum order amount of $${this.maximumAmount} exceeded`);
  }
  
  if (customerId) {
    if (this.excludedCustomers.includes(customerId)) {
      errors.push('Coupon not applicable for this customer');
    }
    
    if (this.applicableCustomers.length > 0 && !this.applicableCustomers.includes(customerId)) {
      errors.push('Coupon not applicable for this customer');
    }
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
};

CouponSchema.methods.validateForCart = async function(cartItems: any[]) {
  // Check if coupon applies to any items in cart
  if (this.applicableProducts.length > 0) {
    const hasApplicableProduct = cartItems.some(item => 
      this.applicableProducts.includes(item.product._id || item.product)
    );
    if (!hasApplicableProduct) {
      return { valid: false, errors: ['No applicable products in cart'] };
    }
  }
  
  if (this.excludedProducts.length > 0) {
    const hasExcludedProduct = cartItems.some(item => 
      this.excludedProducts.includes(item.product._id || item.product)
    );
    if (hasExcludedProduct) {
      return { valid: false, errors: ['Cart contains excluded products'] };
    }
  }
  
  // Similar validation for categories and brands would go here
  
  return { valid: true, errors: [] };
};

CouponSchema.methods.calculateDiscount = function(orderTotal: number, cartItems?: any[]) {
  let discountAmount = 0;
  
  switch (this.discountType) {
    case 'percentage':
      discountAmount = (orderTotal * this.discountValue) / 100;
      if (this.maximumDiscount) {
        discountAmount = Math.min(discountAmount, this.maximumDiscount);
      }
      break;
      
    case 'fixed':
      discountAmount = Math.min(this.discountValue, orderTotal);
      break;
      
    case 'free_shipping':
      // This would be handled separately in shipping calculation
      discountAmount = 0;
      break;
      
    case 'buy_x_get_y':
      // Complex calculation for buy X get Y
      if (this.buyXGetY && cartItems) {
        discountAmount = this.calculateBuyXGetYDiscount(cartItems);
      }
      break;
  }
  
  return Math.round(discountAmount * 100) / 100; // Round to 2 decimal places
};

CouponSchema.methods.calculateBuyXGetYDiscount = function(cartItems: any[]) {
  if (!this.buyXGetY) return 0;
  
  const { buyQuantity, getQuantity, buyProducts, getProducts, getDiscountType, getDiscountValue } = this.buyXGetY;
  
  // Count qualifying buy items
  let qualifyingBuyQuantity = 0;
  for (const item of cartItems) {
    if (buyProducts.length === 0 || buyProducts.includes(item.product._id || item.product)) {
      qualifyingBuyQuantity += item.quantity;
    }
  }
  
  // Calculate how many free items customer gets
  const freeItemSets = Math.floor(qualifyingBuyQuantity / buyQuantity);
  const totalFreeQuantity = freeItemSets * getQuantity;
  
  if (totalFreeQuantity === 0) return 0;
  
  // Find items to apply discount to
  const targetProducts = getProducts.length > 0 ? getProducts : buyProducts;
  let discountAmount = 0;
  let remainingFreeQuantity = totalFreeQuantity;
  
  for (const item of cartItems) {
    if (remainingFreeQuantity <= 0) break;
    
    const isTargetProduct = targetProducts.length === 0 || 
      targetProducts.includes(item.product._id || item.product);
    
    if (isTargetProduct) {
      const discountQuantity = Math.min(item.quantity, remainingFreeQuantity);
      
      if (getDiscountType === 'free') {
        discountAmount += item.unitPrice * discountQuantity;
      } else if (getDiscountType === 'percentage') {
        discountAmount += (item.unitPrice * discountQuantity * getDiscountValue) / 100;
      } else if (getDiscountType === 'fixed') {
        discountAmount += Math.min(getDiscountValue, item.unitPrice) * discountQuantity;
      }
      
      remainingFreeQuantity -= discountQuantity;
    }
  }
  
  return discountAmount;
};

CouponSchema.methods.incrementUsage = function() {
  this.usageCount += 1;
  
  // Auto-update status if used up
  if (this.usageLimit && this.usageCount >= this.usageLimit) {
    this.status = 'used_up';
  }
  
  return this.save();
};

CouponSchema.methods.decrementUsage = function() {
  this.usageCount = Math.max(0, this.usageCount - 1);
  
  // Reactivate if was used up but now has uses remaining
  if (this.status === 'used_up' && this.usageCount < (this.usageLimit || Infinity)) {
    this.status = 'active';
  }
  
  return this.save();
};

export default mongoose.models.Coupon || mongoose.model<ICoupon>('Coupon', CouponSchema);